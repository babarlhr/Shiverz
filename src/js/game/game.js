(function(exports){
    require('../engine/modula.js').use();
    var assets = require('./assets.js');
    var settings = require('./settings.js');
    var ents = require('./entities.js');

    var Player = Class.extend({
        init: function(opt){
            opt = opt || {};
            this.name  = opt.name || 'unnamed';
            this.game  = opt.game || null;
            this.state = 'new';   // 'new','spawning','playing'
            this.type  = opt.type || 'local';   // 'local', 'remote', 'ai'
            this.team  = opt.team || 'spectator'; // 'spectator','auto','red','blue','foes','monsters'
            this.ship  = opt.ship || null;
            this.health = 100;
            this.respawnTimer = null;

            //Networking
            this.socket = opt.socket || null;
            this.controls = [];
            this.shipstates = [];
            this.time = 0;  //time of the mainloop
            this.rtt  = new RunningMean({length: 10, value: 0});
        },
        ping:function(time){
            if(this.time !== 0 && this.time !== time){
                this.rtt.push(time-this.time);
            }
            this.time = time;
        },
        getState: function(){
            return {
                name: this.name,
                state: this.state,
                type: this.type,
                team: this.team,
                ship: this.ship ? this.ship.getState(): undefined,
                health: this.health,
            };
        },
        setState: function(plyr){
            this.name = plyr.name || this.name;
            this.type = plyr.type || this.type;
            this.team = plyr.team || this.team;
            this.health = plyr.health !== undefined ? plyr.health : this.health;
            if(this.game && !this.ship && plyr.ship){
                var ship = this.game.spawnPlayer(this,new V2());
                ship.setState(plyr.ship);
            }
        },
        isDead: function(){
            return this.health <= 0;
        },
        kill: function(){
            this.health = -10000;
        },
    });
    exports.Player = Player;

	var Game = Class.extend({
        init: function(opt){
            opt = opt || {};
            this.localPlayerName = opt.localPlayerName || 'UnnamedPlayer';
            this.players = {};
            this.level = new ents.Level();
            if(serverSide){
                this.level.generate();
            }
            this.entclasses = {}; //maps game entities names to their classes
            this.entsByGuid = {};

            ents.GameEnt.game = this; //FIXME ?

            // Networking
            this.serverUrl = opt.serverUrl || 'localhost';
            this.serverPort = opt.serverPort || 8080;
            this.serverTime = 0;
            this.rtt = new RunningMean({length:10,value:0});

            // Guids are unique numbers identifying game entities across the
            // network
            
            this.guidBase = 0;  // 'prefix' for entities generated by this instance
            this.guidIncr = 0.0000000000001;   
            this.guidBaseIncr = 1;
            this.guidNext  = this.guidBase + this.guidIncr;
            this.guidNextBase = this.guidBase + this.guidBaseIncr;
		},
        newGuid : function(){
            var guid = this.guidNext;
            this.guidNext += this.guidIncr;
            return guid;
        },
        newGuidBase: function(){
            if(serverSide){
                var guidb = this.guidNextBase;
                this.guidNextBase += this.guidBaseIncr;
                return guidb;
            }else{
                throw new Error('only the server can generate new guid bases');
            }
        },
        setGuidBase: function(guidBase){
            if(clientSide){
                console.log('new guid base:',guidBase);
                this.guidBase = guidBase;
                this.guidNext = guidBase + this.guidIncr;
            }else{
                throw new Error('you cannot change the guid base of the server');
            }
        },
        ping: function(serverTime){
            if(this.serverTime !== 0 && this.serverTime !== serverTime){
                this.rtt.push(serverTime - this.serverTime);
            }
            this.serverTime = serverTime;
        },
        getServerUrl: function(){
            return 'ws://'+this.serverUrl+':'+this.serverPort;
        },
        addPlayer: function(player){
            this.players[player.name] = player;
            player.game  =  this;
            console.log('Game: new player: ',player.name);
        },
        remPlayer: function(playername){
            if(this.players[playername].ship){
                this.players[playername].ship.destroy();
            }
            delete this.players[playername];
            console.log('Game: removed player: ',playername);
        },
        changeTeam: function(playername,team){
            this.players[playername].team = team;
        },
        getState: function(){
            var players = {};
            for(player in this.players){
                players[player] = this.players[player].getState();
            }
            var level = this.level.getState();
            return {players: players, level: level};
        },
        setState: function(game){
            console.log('SetState:',game);
            this.loadLevel(game.level);
            this.players = {};
            for(player in game.players){
                var p = new Player({game:this});
                p.setState(game.players[player]);
                this.addPlayer(p);
            }
        },
        loadLevel: function(arg){
            console.log('Loading level');
            if(typeof arg === 'string'){
                var newlevel = new ents.Level({name:arg});
            }else{
                var newlevel = new ents.Level(arg);
            }
            this.level.destroy();
            this.level = newlevel;
            this.main.scene.add(newlevel);
        },
        getLocalPlayer: function(){
            for(name in this.players){
                var p = this.players[name];
                if(p.type === 'local'){
                    return p;
                }
            }
            return null;
        },
        spawnPlayer: function(player,pos){
            if(!pos){
                var spawns = this.level.spawns[player.team];
                var spawn =  spawns[Math.floor(Math.random()*spawns.length)];
                pos = new V2(spawn||[0,0]).add(V2(0.5,0.5)).mult(this.level.grid.cellSize);
            }
            console.log('spawning player: '+player.name+'@'+pos);
            var ship = new ents.Ship({
                game: this,
                player: player,
                pos: pos,
            });
            player.ship = ship;
            player.health = 100;
            this.main.scene.add(ship);
            return ship;
        },
        spawnEnt: function(name,playername,args){
            console.log('Player: '+playername+' Spawning Entity: '+name+' with args:'+JSON.stringify(args));
            if(this.entclasses[name] && this.players[playername]){
                var ent = new (this.entclasses[name])(this.players[playername],args);
                this.main.scene.add(ent);
                this.entsByGuid[ent.guid] = ent;
            }else{
                throw new Error('could not spawn entity');
            }
            if(serverSide){
                this.send('all','spawn_ent',{name:name, playername:playername, args:args});
            }
        },
        destroyEnt: function(guid){
            if(this.entsByGuid[guid]){
                this.entsByGuid[guid].destroy();
                delete this.entsByGuid[guid];
                if(serverSide){
                    this.send('all','destroy_ent',guid);
                }
            }
        },
        updatePlayer: function(player){
            if(player.isDead()){
                if(player.ship){
                    player.ship.destroy();
                    player.spawnTimer = this.main.scene.timer(2);
                    this.send('all','kill_player',player.name);
                }else if(player.spawnTimer && player.spawnTimer.expired()){
                    var ship = this.spawnPlayer(player);
                    this.send('all','spawn_player',{player: player.name, pos: ship.tr.getPos()});
                }
            }
        },
        onGameUpdate: function(){
            if(serverSide){
                for(player in this.players){
                    var p = this.players[player];
                    if(p.team !== 'spectator'){
                        if(p.state === 'new' || p.state === 'spawning'){
                            var ship = this.spawnPlayer(p);
                            this.send('all','spawn_player',{player: p.name, pos: ship.tr.getPos()});
                            p.state = 'playing'; //FIXME send over network
                        }else{
                            this.updatePlayer(p);
                        }
                    }
                }
            }
        },
        send: function(destination,type,data){
            var msg = {type:type, data:data || {}};
            if(clientSide){
                // console.log('Client: sending '+type+' to '+destination+' with data:',data);
                if(destination === 'server'){
                    this.socketToServer.send(JSON.stringify(msg));
                }else{ 
                    throw new Error('send(): invalid destination for message of type:'+type);
                }
            }else{
                // console.log('Server: sending '+type+' to '+destination+' with data:',JSON.stringify(data).substr(0,1000));
                if(typeof destination === 'string'){
                    if(destination === 'all'){
                        var strmsg = JSON.stringify(msg);
                        for(player in this.players){
                            this.players[player].socket.send(strmsg);
                        }
                    }else if(destination[0] === '!'){ //FIXME what if the username starts with ! ?
                        destination = destination.slice(1);
                        for(player in this.players){
                            if(player !== destination){
                                this.players[player].socket.send(JSON.stringify(msg));
                            }
                        }
                    }else{
                        destination = destination.slice(1);
                        if(this.players[destination]){
                            this.players[destination].socket.send(JSON.stringify(msg));
                        }
                    }
                }else{
                    destination.send(JSON.stringify(msg));
                }
            }
        },
        _onPlayerConnected: function(socket){
            var self = this;
            console.log('Server: new client connected');
            var player = null;
            socket.on('message', function(message){
                var msg  = JSON.parse(message);
                //console.log('Server: received message: '+JSON.stringify(message).substr(0,1000));
                if(msg.type === 'greeting'){
                    var newPlayerName = msg.data.playerName;
                    while(self.players[newPlayerName]){
                        newPlayerName = newPlayerName+'I';
                    }
                    self.send(socket,'greeting',{
                        playerName: newPlayerName, 
                        playerTeam:'spectator',
                        guidBase: self.newGuidBase(),
                        gamestate: self.getState(),
                    });
                    player = new Player({ game: self, name: newPlayerName, type: 'remote', socket:socket, team:'spectator'});
                    self.addPlayer(player);
                    self.send('!'+newPlayerName,'new_player',player.getState());
                    socket.on('close',function(code,message){self._onPlayerDisconnected(newPlayerName);});
                }else if(msg.type === 'controls'){
                    player.controls.push(msg.data);
                }else if(msg.type === 'change_team'){
                    self.changeTeam(player.name,msg.data);
                    self.send('all','change_team',{player:player.name, team:msg.data});
                }else if(msg.type === 'ping'){
                    player.ping(msg.data.time);
                    self.send(socket,'ping',{time: self.main.time});
                }else if(msg.type === 'suicide'){
                    console.log('Player: '+player.name+' committed suicide');
                    player.kill();
                }else{
                    console.log('unknown message:',msg);
                }
            });
        },
        _onPlayerDisconnected: function(player){
            console.log('Server: player disconnected: ',player);
            this.remPlayer(player);
            this.send('all','player_disconnected',player);
        },
        _onConnectedToServer: function(){
            console.log('Client: connected to server');
            this.send('server','greeting',{playerName:this.localPlayerName});
        },
        _onMessageFromServer: function(message){
            var msg = JSON.parse(message.data);
            //console.log('Received message from server: ',msg);
            if(msg.type === 'greeting'){
                this.setGuidBase(msg.data.guidBase);
                this.setState(msg.data.gamestate);
                this.localPlayerName = msg.data.playerName;
                this.addPlayer(new Player({game: this, name:this.localPlayerName, type: 'local', team:msg.data.playerTeam}));
                this.send('server','ping',{time: this.main.time});
            }else if(msg.type === 'new_player'){
                var player = new Player({game:this});
                player.setState(msg.data);
                this.addPlayer(player);
            }else if(msg.type === 'player_disconnected'){
                this.remPlayer(msg.data);
            }else if(msg.type === 'spawn_player'){
                this.spawnPlayer(this.players[msg.data.player],msg.data.pos);
            }else if(msg.type === 'change_team'){
                this.changeTeam(msg.data.player,msg.data.team);
            }else if(msg.type === 'kill_player'){
                var player = this.players[msg.data];
                if(player && player.ship){
                    player.ship.destroy();
                }
            }else if(msg.type === 'ship_update'){
                var player = this.players[msg.data.player];
                if(player){
                    player.shipstates.push(msg.data.state);
                }
            }else if(msg.type === 'ping'){
                this.ping(msg.data.time);
                this.send('server','ping',{time:this.main.time});
            }else if(msg.type === 'spawn_ent'){
                console.log('Spawning entity: ',msg.data);
                this.spawnEnt(msg.data.name, msg.data.playername, msg.data.args);
            }else if(msg.type === 'destroy_ent'){
                console.log('Destroying entity: ',msg.data);
                this.destroyEnt(msg.data);
            }else{
                console.log('unkwnown message from server:',msg);
            }
        },
		start: function(){
            var self = this;
            if(clientSide){
                var renderer = new RendererCanvas2d({
                    passes:[
                    'buildings',
                    'bgblocks',
                    'ships',
                    'projectiles',
                    'explosions',
                    'blocks',
                    ],
                    canvas: document.getElementById('game_canvas'), 
                    getSize: function(){
                        return new V2(window.innerWidth, window.innerHeight);
                    },
                    background: 'rgba(40,35,30,1)',
                    alwaysRedraw: true,
                });
                console.log('Client: Connecting to server: '+this.getServerUrl());
                this.socketToServer = new WebSocket(this.getServerUrl());
                this.socketToServer.onopen = function(){ self._onConnectedToServer(); };
                this.socketToServer.onmessage = function(message){ self._onMessageFromServer(message); };
                this.serverSocket = null;
            }else{
                this.serverSocket = new (require('ws').Server)({port: this.serverPort});
                this.serverSocket.on('connection',function(socket){self._onPlayerConnected(socket);});
                this.socketToServer = null;
                renderer = null;
            }
            var GameScene = Scene.extend({
                renderer: renderer,
                camera : new ents.GameCamera({game:self}),
                onSceneStart: function(){
                    this.add(self.level);
                },
                onFrameStart: function(){
                    self.onGameUpdate();
                },
            });
            this.main = new Main({
                input: new Input({
                    alias: settings.bindings,
                }),
                scene: new GameScene(),
                fps: 60,
            });
            this.main.run();
		},
		exit:  function(){
            this.main.exit();
		},
	});
    exports.Game = Game;
})(exports);
